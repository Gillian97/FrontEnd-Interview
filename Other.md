# 软件架构 MVC MVP MVVM

## MVC

软件可以分成三个部分。

- 视图（View）：用户界面。
- 控制器（Controller）：业务逻辑
- 模型（Model）：数据保存

通信方式:

1. View 传送指令到 Controller
2. Controller 完成业务逻辑后，要求 Model 改变状态
3. Model 将新的数据发送到 View，用户得到反馈

![img](images/MVC.PNG)

## MVP

MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。

1. 各部分之间的通信，都是双向的。

2. View 与 Model 不发生联系，都通过 Presenter 传递。

3. View 非常薄，不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 **Presenter**非常厚，所有逻辑都部署在那里。

![img](images/MVP.PNG)

## MVVM

MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。[Angular](https://angularjs.org/) 和 [Ember](http://emberjs.com/) 都采用这种模式。

![img](images/MVVM.PNG)

# 加密算法

## 哈希函数

标识原信息, 把任意长度的数据计算成固定长度的数据, 达到加密效果

- 不可逆(不能根据哈希值逆推出原内容)
- 不同内容的哈希值相同的概率相当小
- 原始内容的任意一点改变, 哈希值都会有巨大的不同

输入: 任意长

输出: 定长的信息摘要(Message Digest)

使用场景:

- 密码校验
- 文件校验

## MD5

Message Digest Algorithm MD5，消息摘要算法第五版

**返回值**

二进制 128bit <=> 32位十六进制数

**不足**

- 寻找一对碰撞(一对不同数据MD5值相同)的速度加快, 即安全性会有所降低
- 彩虹表
  - 是一个庞大的数据库，这个数据库里收集了着咱们所有人**常用的密码**，以及**这些密码对应的MD5值、SHA-X值等哈希值**（当然还有别的各种哈希算法的哈希值，不止MD5和SHA-X）
  - 主流彩虹表的大小一般都是100G以上

**应对**

- 复杂密码
- 简单密码复杂化(加盐)
  - 加盐: 在密码的任意位置插入一些指定的字符串（即盐值salt）的过程
    - 每个用户盐值唯一, 防止大面积被破解
    - 服务端为每个用户随机生成, 保存在数据库中
    - 分散插入密码中, 不要简单拼接

**开发中实际采用方案**

盐值由服务端生成并存储, 加盐可以由服务端或者客户端进行.

1. 客户端加盐
   1. 客户端调用接口请求盐值
   2. 客户端 MD5(pwd + salt)
   3. 客户端调用登录接口, 服务端保存密码
2. 服务端加盐
   1. 客户端MD5(pwd)
   2. 客户端调用登录接口
   3. 服务端 MD5(MD5(pwd) + salt), 服务端保存密码

**具体应用场景**

- 密码加密
- 数字签名

## SHA 家族算法

Secure Hash Algorithm，安全散列算法, 包括SHA-1、SHA-256等多种算法

### SHA-1

SHA-1算法和MD5算法都由 MD4算法导出，因此他们俩的特点、缺陷、应用场景基本是相同的。

返回值:

二进制 160bit <=> 40位十六进制数, 因此更加安全.

### SHA-2

可再分为六个不同的算法标准, 包括：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。

SHA-256

返回值 256bit <=> 64 位十六进制数



# 设计模式

## 创建型模式

### 单例模式

目的:

保证一个类只有一个实例， 并提供一个访问该实例的全局节点。最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。

解决两个问题:

1. 一个类只有一个实例.

   实现这类构造函数需要特殊的设计: **必须**总是返回一个新对象。

2. 为该实例提供一个全局访问的节点. 保护唯一实例的数据不被其他代码覆盖.

实现:

- 将默认构造函数设为私有， 防止其他对象使用单例类的 `new`运算符。

- 新建一个静态构建方法作为构造函数。

  该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。

如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。

应用举例:

redux 中的 store

代码实现示例

```typescript
/**
 * The Singleton class defines the `getInstance` method that lets clients access
 * the unique singleton instance.
 */
class Singleton {
    private static instance: Singleton;

    /**
     * The Singleton's constructor should always be private to prevent direct
     * construction calls with the `new` operator.
     */
    private constructor() { }

    /**
     * The static method that controls the access to the singleton instance.
     *
     * This implementation let you subclass the Singleton class while keeping
     * just one instance of each subclass around.
     */
    public static getInstance(): Singleton {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }

        return Singleton.instance;
    }

    /**
     * Finally, any singleton should define some business logic, which can be
     * executed on its instance.
     */
    public someBusinessLogic() {
        // ...
    }
}

/**
 * The client code.
 */
function clientCode() {
    const s1 = Singleton.getInstance();
    const s2 = Singleton.getInstance();

    if (s1 === s2) {
        console.log('Singleton works, both variables contain the same instance.');
    } else {
        console.log('Singleton failed, variables contain different instances.');
    }
}

clientCode();
```



### 生成器模式

背景: 分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。

- 不可能为每一个不同功能的对象都创建一个子类, 子类数量太多. 
- 通过传入参数true/false的形式使用构造函数时, 绝大多数参数又没有用.

原理:

生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为*生成器*的独立对象中。

> 生成器模式让你能够分步骤创建复杂对象。 生成器不允许其他对象访问正在创建中的产品。

![应用生成器模式](https://refactoringguru.cn/images/patterns/diagrams/builder/solution1.png)

重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。

在构造步骤需要不同的实现时, 可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 

> 不同生成器以不同方式执行相同的任务。

![img](https://refactoringguru.cn/images/patterns/content/builder/builder-comic-1-zh.png)

只有在调用构造步骤的客户端代码可以通过通用接口与建造者进行交互时， 这样的调用才能返回需要的房屋。

主管类:

根据实际情况确定是否需要. 主管类中可以放置一些例行程序步骤, 而构造器提供步骤的实现.

> 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。

实现:

![生成器设计模式结构](https://refactoringguru.cn/images/patterns/diagrams/builder/structure.png)

### 原型模式

**定义**

能够复制已有对象， 而又无需使代码依赖它们所属的类。

直接循环目标对象的所有属性并将其赋值给新对象, 对于有私有属性的对象来说, 并不可行.

**解决**

原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 `克隆`方法。

所有的类对 `克隆`方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。

**支持克隆的对象即为*原型*。** 当你的对象有几十个成员变量和几百种类型时， *对其进行克隆甚至可以代替子类的构造*。

其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。

**实现**

1. **原型** （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 `clone`克隆的方法。
2. **具体原型** （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。
3. **客户端** （Client） 可以复制实现了原型接口的任何对象。

![原型设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/prototype/structure.png)

**适用场景**

1. **如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。**

   这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。 即使不考虑代码耦合的情况， 你的代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息。

   原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。

2. 如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。

   在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。

   客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。

### 工厂方法模式

**亦称：** 虚拟构造函数、Virtual Constructor、Factory Method

**定义**

在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

**解决**

不能需要一种实例就创建一个类, 可以避免直接使用 new 进行实例的创建. 

工厂方法模式建议使用特殊的*工厂*方法代替对于对象构造函数的直接调用 （即使用 `new`运算符）。 不用担心， 对象仍将通过 `new`运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。

![创建者类结构](https://refactoringguru.cn/images/patterns/diagrams/factory-method/solution1.png)

现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型。

有一点需要注意: 仅当这些产品具有**共同的基类或者接口**时， 子类才能返回不同类型的产品， 同时**基类中的工厂方法**还应将其返回类型 声明为这一共有接口。(所有产品都必须使用同一接口。)

![产品对象层次结构](https://refactoringguru.cn/images/patterns/diagrams/factory-method/solution2-zh.png)

举例来说，  `卡车`Truck和 `轮船`Ship类都必须实现 `运输`Transport接口， 该接口声明了一个名为 `deliver`交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。  `陆路运输`Road­Logistics类中的工厂方法返回卡车对象， 而 `海路运输`Sea­Logistics类则返回轮船对象。

> 只要产品类实现一个共同的接口， 你就可以将其对象传递给客户代码， 而无需提供额外数据。

调用工厂方法的代码 （通常被称为*客户端*代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 `运输` 。 客户端知道所有运输对象都提供 `交付`方法， 但是并不关心其具体实现方式。

**实现**

1. **产品** （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。

2. **具体产品** （Concrete Products） 是产品接口的不同实现。

3. **创建者** （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。

   你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。

   注意， 尽管它的名字是创建者， 但他最主要的职责并**不是**创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。

4. **具体创建者** （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。

   注意， 并不一定每次调用工厂方法都会**创建**新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。

![工厂方法模式结构](https://refactoringguru.cn/images/patterns/diagrams/factory-method/structure.png)

**适用场景**

1. **当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。**

   工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。

   例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。

2. **如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。**

   继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？

   解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。

   让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 `圆形按钮`Round­Button子类来继承标准的 `按钮`Button类。 但是， 你需要告诉 `UI框架`UIFramework类使用新的子类按钮代替默认按钮。

   为了实现这个功能， 你可以根据基础框架类开发子类 `圆形按钮 UI`UIWith­Round­Buttons ， 并且重写其 `create­Button`创建按钮方法。 基类中的该方法返回 `按钮`对象， 而你开发的子类返回 `圆形按钮`对象。 现在， 你就可以使用 `圆形按钮 UI`类代替 `UI框架`类。 就是这么简单！

3. **如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。**

   在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。

   让我们思考复用现有对象的方法：

   1. 首先， 你需要创建存储空间来存放所有已经创建的对象。
   2. 当他人请求一个对象时， 程序将在对象池中搜索可用对象。
   3. …然后将其返回给客户端代码。
   4. 如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。

   这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。

   可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是**新对象**， 其无法返回现有实例。

   因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。

**优缺点**

优点:

- 你可以避免创建者和具体产品之间的紧密耦合。
-  *单一职责原则*。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。
-  *开闭原则*。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。

缺点:

- 应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。

## 结构型模式

### 外观模式

**亦称：** 门面模式、Facade

能为程序库、 框架或其他复杂类提供一个简单的接口。

外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。

如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便，

例如， 上传猫咪搞笑短视频到社交媒体网站的应用可能会用到专业的视频转换库， 但它只需使用一个包含 `encode­(filename, format)`方法 （以文件名与文件格式为参数进行编码的方法） 的类即可。 在创建这个类并将其连接到视频转换库后， 你就拥有了自己的第一个外观。

真实示例:

![电话购物的示例](https://refactoringguru.cn/images/patterns/diagrams/facade/live-example-zh.png)

当你通过电话给商店下达订单时， 接线员就是该商店的所有服务和部门的外观。 接线员为你提供了一个同购物系统、 支付网关和各种送货服务进行互动的简单语音接口。

实现:

1. **外观** （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。

2. 创建**附加外观** （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。

3. **复杂子系统** （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。

   子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。

4. **客户端** （Client） 使用外观代替对子系统对象的直接调用。

![外观设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/facade/structure.png)

### 组合模式

**亦称：** 对象树、Object Tree、Composite

使用它**将对象组合成树状结构**， 并且能像使用独立对象一样使用它们。

背景:

如果应用的核心模型能用树状结构表示， 在应用中使用组合模式才有价值。

例如， 你有两类对象：  `产品`和 `盒子` 。 一个盒子中可以包含多个 `产品`或者几个较小的 `盒子` 。 这些小 `盒子`中同样可以包含一些 `产品`或更小的 `盒子` ， 以此类推。

假设你希望在这些类的基础上开发一个定购系统。 订单中可以包含无包装的简单产品， 也可以包含装满产品的盒子……以及其他盒子。 此时你会如何计算每张订单的总价格呢？

你可以尝试直接计算： 打开所有盒子， 找到每件产品， 然后计算总价。 这在真实世界中或许可行， 但在程序中， 你并不能简单地使用循环语句来完成该工作。 你必须事先知道所有 `产品`和 `盒子`的类别， 所有盒子的嵌套层数以及其他繁杂的细节信息。 因此， 直接计算极不方便， 甚至完全不可行。

解决方案:

组合模式建议使用一个通用接口来与 `产品`和 `盒子`进行交互， 并且在该接口中声明一个计算总价的方法。

那么方法该如何设计呢？ 对于一个产品， 该方法直接返回其价格； 对于一个盒子， 该方法遍历盒子中的所有项目， 询问每个项目的价格， 然后返回该盒子的总价格。 如果其中某个项目是小一号的盒子， 那么当前盒子也会遍历其中的所有项目， 以此类推， 直到计算出所有内部组成部分的价格。 你甚至可以在盒子的最终价格中增加额外费用， 作为该盒子的包装费用。

![组合模式建议的解决方案](https://refactoringguru.cn/images/patterns/content/composite/composite-comic-1-zh.png)

(树的遍历, 例如计算树的深度时, 使用的思想与此类似)

该方式的最大优点在于你无需了解构成树状结构的对象的具体类。 你也无需了解对象是简单的产品还是复杂的盒子。 你只需调用通用接口以相同的方式对其进行处理即可。 当你调用该方法后， 对象会将请求沿着树结构传递下去。

结构:

1. **组件** （Component） 接口描述了树中简单项目和复杂项目所共有的操作。

2. **叶节点** （Leaf） 是树的基本结构， 它不包含子项目。

   一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。

3. **容器** （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。

   容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。

4. **客户端** （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。

![组合设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/composite/structure-zh.png)

应用场景:

1. 如果你需要实现树状对象结构， 可以使用组合模式。

   组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。

2. 如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。

   组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。

### 代理模式

能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。

结构:

1. **服务接口** （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。
2. **服务** （Service） 类提供了一些实用的业务逻辑。
3. **代理** （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。
4. **客户端** （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。

![代理设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/proxy/structure.png)

## 行为模式

### 迭代器模式

能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。

背景:

集合是编程中最常使用的数据类型之一。 尽管如此， 集合只是一组对象的容器而已。大部分集合使用简单列表存储元素。 但有些集合还会使用栈、 树、 图和其他复杂的数据结构。

无论集合的构成方式如何， 它都必须提供某种访问元素的方式， 便于其他代码使用其中的元素。 集合应提供一种能够遍历元素的方式， 且保证它不会周而复始地访问同一个元素。

如果你的集合基于列表， 那么这项工作听上去仿佛很简单。 但如何遍历复杂数据结构 （例如树） 中的元素呢？ 例如， 今天你需要使用深度优先算法来遍历树结构， 明天可能会需要广度优先算法； 下周则可能会需要其他方式 （比如随机存取树中的元素）。

不断向集合中添加遍历算法会模糊其 “高效存储数据” 的主要职责。 此外， 有些算法可能是根据特定应用订制的， 将其加入泛型集合类中会显得非常奇怪。

另一方面， 使用多种集合的客户端代码可能并不关心存储数据的方式。 不过由于集合提供不同的元素访问方式， 你的代码将不得不与特定集合类进行耦合。

总之: 在你不关心数据的存储方式的前提下, 想要访问不同集合中的数据, 但是又不想使用不同的遍历方法, 希望不同的集合都提供统一的方法去访问集合中的数据.

解决:

迭代器模式的主要思想是将集合的遍历行为抽取为单独的*迭代器* 对象。

> 迭代器可实现多种遍历算法, 采用不同的方式遍历集合。 多个迭代器对象可同时遍历同一个集合。

![迭代器可以实现不同算法](https://refactoringguru.cn/images/patterns/diagrams/iterator/solution1.png)

除实现自身算法外， 迭代器还封装了遍历操作的所有细节， 例如当前位置和末尾剩余元素的数量。 因此， 多个迭代器可以在相互独立的情况下同时访问集合。

迭代器通常会提供一个获取集合元素的基本方法。 客户端可不断调用该方法直至它不返回任何内容， 这意味着迭代器已经遍历了所有元素。

所有迭代器必须实现相同的接口。 这样一来， 只要有合适的迭代器， 客户端代码就能兼容任何类型的集合或遍历算法。 如果你需要采用特殊方式来遍历集合， 只需创建一个新的迭代器类即可， 无需对集合或客户端进行修改。

结构:

1. **迭代器** （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。

2. **具体迭代器** （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。

3. **集合** （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。

4. **具体集合** （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。

5. **客户端** （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。

   客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。

![迭代器设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/iterator/structure.png)



### 观察者模式(发布订阅)

**定义**

允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。

**背景**

我们似乎遇到了一个矛盾： 要么让顾客浪费时间检查产品是否到货， 要么让商店浪费资源去通知没有需求的顾客。

**解决**

拥有一些值得关注的状态的对象通常被称为*目标*， 由于它要将自身的状态改变通知给其他对象， 我们也将其称为*发布者* （publisher）。 所有希望关注发布者状态变化的其他对象被称为*订阅者* （subscribers）。

观察者模式建议你为发布者类添加订阅机制， 让每个对象都能订阅或取消订阅发布者事件流。该机制包括 1） 一个用于存储订阅者对象引用的列表成员变量； 2） 几个用于添加或删除该列表中订阅者的公有方法。

> 订阅机制允许对象订阅事件通知。

![订阅机制](https://refactoringguru.cn/images/patterns/diagrams/observer/solution1-zh.png)

现在， 无论何时发生了重要的发布者事件， 它都要遍历订阅者并调用其对象的特定通知方法。

规定所有订阅者类实现同样的接口, 发布者仅仅通过该接口与订阅者交互. 接口中必须声明通知方法及其参数， 这样发布者在发出通知时还能传递一些上下文数据。

> 发布者调用订阅者对象中的特定通知方法来通知订阅者。

![通知方法](https://refactoringguru.cn/images/patterns/diagrams/observer/solution2-zh.png)

如果你的应用中有多个不同类型的发布者， 且希望订阅者可兼容所有发布者， 那么你甚至可以进一步**让所有订阅者遵循同样的接口。 该接口仅需描述几个订阅方法即可。** 这样订阅者就能在不与具体发布者类耦合的情况下通过接口观察发布者的状态。

**结构**

1. **发布者** （Publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。
2. 当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。
3. **订阅者** （Subscriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 `update`更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。
4. **具体订阅者** （Concrete Subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。
5. 订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。
6. **客户端** （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。

![观察者设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/observer/structure-indexed.png)



**适用场景**

1. 当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。

   当你使用图形用户界面类时通常会遇到一个问题。 比如， 你创建了自定义按钮类并允许客户端在按钮中注入自定义代码， 这样当用户按下按钮时就会触发这些代码。

   观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。 你可在按钮中添加订阅机制， 允许客户端通过自定义订阅类注入自定义代码。

2. 当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。

   订阅列表是动态的， 因此订阅者可随时加入或离开该列表。

**优缺点**

优点:

- *开闭原则*。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。
-  你可以在运行时建立对象之间的联系。

缺点:

-  订阅者的通知顺序是随机的。

### 中介者模式

**定义**

能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。

**背景**

元素之间错综复杂的依赖关系导致元素不能够复用, 因为其本身可能包含业务逻辑.

> 用户界面中各元素间的关系会随程序发展而变得混乱。

![用户界面中各元素间的混乱关系](https://refactoringguru.cn/images/patterns/diagrams/mediator/problem1-zh.png)

**解决**

中介者模式建议你停止组件之间的直接交流并使其相互独立。 这些组件必须调用特殊的中介者对象， 通过中介者对象重定向调用行为， 以间接的方式进行合作。 最终， 组件仅依赖于一个中介者类， 无需与多个其他组件相耦合。

在资料编辑表单的例子中， 对话框 （Dialog） 类本身将作为中介者， 其很可能已知自己所有的子元素， 因此你甚至无需在该类中引入新的依赖关系。

> UI 元素必须通过中介者对象进行间接沟通。

![UI 元素必须通过中介者进行沟通。](https://refactoringguru.cn/images/patterns/diagrams/mediator/solution1-zh.png)

绝大部分重要的修改都在实际表单元素中进行。

让我们想想提交按钮。 之前， 当用户点击按钮后， 它必须对所有表单元素数值进行校验。 而现在它的唯一工作是将点击事件通知给对话框。 收到通知后， 对话框可以自行校验数值或将任务委派给各元素。 这样一来， 按钮不再与多个表单元素相关联， 而仅依赖于对话框类。

你还可以为所有类型的对话框抽取通用接口， 进一步削弱其依赖性。 接口中将声明一个所有表单元素都能使用的通知方法， 可用于将元素中发生的事件通知给对话框。 这样一来， 所有实现了该接口的对话框都能使用这个提交按钮了。

采用这种方式， 中介者模式让你能在单个中介者对象中封装多个对象间的复杂关系网。 类所拥有的依赖关系越少， 就越易于修改、 扩展或复用。

**结构**

1. **组件** （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。

2. **中介者** （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。

3. **具体中介者** （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。

4. 组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。

   对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。

![中介者设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/mediator/structure-indexed.png)

**适用场景**

1. 当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。

   该模式让你将对象间的所有关系抽取成为一个单独的类， 以使对于特定组件的修改工作独立于其他组件。

2. 当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。

   应用中介者模式后， 每个组件不再知晓其他组件的情况。 尽管这些组件无法直接交流， 但它们仍可通过中介者对象进行间接交流。 如果你希望在不同应用中复用一个组件， 则需要为其提供一个新的中介者类。

3. 如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。

   由于所有组件间关系都被包含在中介者中， 因此你无需修改组件就能方便地新建中介者类以定义新的组件合作方式。

优缺点:

优点:

- *单一职责原则*。 

  你可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。

-  *开闭原则*。 

  你无需修改实际组件就能增加新的中介者。

-  你可以减轻应用中多个组件间的耦合情况。

-  你可以更方便地复用各个组件。

缺点:

- 一段时间后， 中介者可能会演化成为[上帝对象](https://refactoringguru.cn/antipatterns/god-object)。

  一个上帝对象(God object)是一个了解过多或者负责过多的对象。


# 业务/设计

## 扫码登录原理

> 网站内嵌二维码微信登录

点击京东登录页面的微信登录按钮, 跳转到一张展示微信二维码的页面

原理: 点击微信登录按钮后, 发送一条请求到京东服务器, 返回 302 暂时重定向到一个新的 url.

![image-20210227230249322](images/image-login5.jpg)

再访问这个 Location 对应的 url, 京东服务器返回一张微信二维码图片的 url.

![image-20210227230054948](images/%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9B%BE%E7%89%87.jpg)

显示二维码之后, 浏览器发请求轮询微信服务器, 用户是否同意登录.

当返回中的 wx_code (授权临时票据)是空时, 说明未登录.

![image-20210227230506686](image-20210227230506686.png)

uuid 不断自增, 浏览器在轮询服务器.

![image-20210227230712722](images/image-login2.jpg)

用户扫码后, 浏览器从缓存中获取图片, 更新二维码样式为扫描成功, 并且继续轮询微信server 用户的登录状态.

![image-20210227232817947](images/image-login3.jpg)

手机点击授权同意, 改变了用户登录状态, 则浏览器轮询后微信服务器返回 code. 浏览器带着 code 请求自己(京东)服务器. 得到 302 后(也设置了 Cookie)重定向到京东首页, 登录成功.

![image-20210227233049923](images/image-login4.jpg)

**授权流程**

当得到用户 `code` 之后，来向微信开放平台通过`code` 加上 `appid` 和 `appsecret`来换取 `access_token`。

下述代码就是我们开头提到的，`appid` 后续会使用到

```javascript
https://open.weixin.qq.com/connect/qrconnect?
appid=wx827225356b689e24
&state=16C44408BCCE66A99882ECB2D85A86567BAA2F274D7E27D688CE2D484A4381D35AFFAD49FD54FB2CA9C787D88B61DE8B
&redirect_uri=https%3A%2F%2Fqq.jd.com%2Fnew%2Fwx%2Fcallback.action%3Fview%3Dnull%26uuid%3Dd7f9f509608744c4aa64c4116896ba5f
&response_type=code
&scope=snsapi_login
复制代码
```

在获得了 `access_token` 后就可以解析用户的一些基本信息，包括头像、用户名、性别、城市等。这样一来，整个微信扫描登录的过程就完成了。

原理图:

![img](images/login_principle.jpg)



补充链接: [微信官方登录原理](https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html) [掘金文章](https://juejin.cn/post/6924218259302694919?utm_source=gold_browser_extension)






# 0227 面试课

## JS 三类循环对比以及性能分析

### for 循环及 ForEach 底层原理

稀疏数组

有很多方法比如 ForEach 等使用起来有问题

```javascript
new Array(10)
[10,,,40]
```

密集数组

```javascript
[10, 20, 30]
```

使用 var 声明, for 和 while 差不多, 类似于 let 的 while.

使用 let 声明, for 比 while 快, 因为 let 声明不是全局, 是块级, 每一次循环都会释放 i. 而 var/let 声明是全局的, 消耗更大, 但是本质没有区别.

for 循环

明确知道循环多少次.

while 循环

不知道循环多少次, 条件达到即可.

ForEach(fn, thisVal) 

比 for 性能差一些, 推荐的原因是看中其函数式编程(更多看中结果, 对过程进行封装, 使用方便, 但是无法管控过程, 性能有所消耗, 多做很多操作). 与之对应的是命令式编程, 看中过程, 对过程掌控更好.

实现 ForEach

```

```

for in 性能最差

迭代当前对象的所有可迭代对象, 私有属性基本上是可迭代, 某些公有属性{出现在原型链上的属性}也可迭代. 因此查找时一定会遍历原型链的所有属性(可或者不可迭代属性).

问题: 

- 遍历顺序以数字优先
- 无法遍历 Symbol 属性
  - 查看浏览器是否兼容 Symbol. If(typeof Symbol !== 'undefined') 浏览器支持 Symbol
- 可以遍历到公有中可枚举的
  - 过程是先找私有属性, 再找公有属性. 因此可以当 hasOwnProperty 不满足时, break 循环

Object.keys() 拿到当前对象的非Synbol 私有属性

Object.getOwnPropertySynbols() 拿到当前对象的 Synbol 私有属性

console.dir()/ dir 详细输出一个对象

for of 循环

比 for in 好一点. 按照迭代器规范进行规范.

 迭代器: 一种规范, 想迭代当前结构该怎么迭代. 部分数据结构实现了迭代器规范, 所有有 [Symbol.iterator] 属性的数据结构都实现了迭代器规范.

实现的数据结构: 数组/部分类数组(arguments)/Set/Map...[对象没有实现]

#### this

函数执行的主体, 即是谁执行函数的, 谁与函数不一定有关系.

与函数在哪创建的和在哪执行的无关. 不一定方法要在 this 指向的对象上.

```

```

构造函数中的 this 是创建的实例

给当前元素的添加事件, 触发事件后, 调用函数.

```javascript
document.body.addEventListener('click', function(){
  console.log(this);
  // document.body
})
```

箭头函数中 this 是所处上下文的 this

call/apply/bind 显示指定 this

鸭子类型

Array.prototype.slice() 浅拷贝

扫码登录/单点登录

### for in 循环的 BUG 及解决方案

## this 以及应用场景

## 输入 url 到页面呈现发生了什么

## 项目难点以及两点
