# 软件架构 MVC MVP MVVM

## MVC

软件可以分成三个部分。

- 视图（View）：用户界面。
- 控制器（Controller）：业务逻辑
- 模型（Model）：数据保存

通信方式:

1. View 传送指令到 Controller
2. Controller 完成业务逻辑后，要求 Model 改变状态
3. Model 将新的数据发送到 View，用户得到反馈

![img](images/MVC.PNG)

## MVP

MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。

1. 各部分之间的通信，都是双向的。

2. View 与 Model 不发生联系，都通过 Presenter 传递。

3. View 非常薄，不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 **Presenter**非常厚，所有逻辑都部署在那里。

![img](images/MVP.PNG)

## MVVM

MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。[Angular](https://angularjs.org/) 和 [Ember](http://emberjs.com/) 都采用这种模式。

![img](images/MVVM.PNG)

# 加密算法

## 哈希函数

标识原信息, 把任意长度的数据计算成固定长度的数据, 达到加密效果

- 不可逆(不能根据哈希值逆推出原内容)
- 不同内容的哈希值相同的概率相当小
- 原始内容的任意一点改变, 哈希值都会有巨大的不同

输入: 任意长

输出: 定长的信息摘要(Message Digest)

使用场景:

- 密码校验
- 文件校验

## MD5

Message Digest Algorithm MD5，消息摘要算法第五版

**返回值**

二进制 128bit <=> 32位十六进制数

**不足**

- 寻找一对碰撞(一对不同数据MD5值相同)的速度加快, 即安全性会有所降低
- 彩虹表
  - 是一个庞大的数据库，这个数据库里收集了着咱们所有人**常用的密码**，以及**这些密码对应的MD5值、SHA-X值等哈希值**（当然还有别的各种哈希算法的哈希值，不止MD5和SHA-X）
  - 主流彩虹表的大小一般都是100G以上

**应对**

- 复杂密码
- 简单密码复杂化(加盐)
  - 加盐: 在密码的任意位置插入一些指定的字符串（即盐值salt）的过程
    - 每个用户盐值唯一, 防止大面积被破解
    - 服务端为每个用户随机生成, 保存在数据库中
    - 分散插入密码中, 不要简单拼接

**开发中实际采用方案**

盐值由服务端生成并存储, 加盐可以由服务端或者客户端进行.

1. 客户端加盐
   1. 客户端调用接口请求盐值
   2. 客户端 MD5(pwd + salt)
   3. 客户端调用登录接口, 服务端保存密码
2. 服务端加盐
   1. 客户端MD5(pwd)
   2. 客户端调用登录接口
   3. 服务端 MD5(MD5(pwd) + salt), 服务端保存密码

**具体应用场景**

- 密码加密
- 数字签名

## SHA 家族算法

Secure Hash Algorithm，安全散列算法, 包括SHA-1、SHA-256等多种算法

### SHA-1

SHA-1算法和MD5算法都由 MD4算法导出，因此他们俩的特点、缺陷、应用场景基本是相同的。

返回值:

二进制 160bit <=> 40位十六进制数, 因此更加安全.

### SHA-2

可再分为六个不同的算法标准, 包括：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。

SHA-256

返回值 256bit <=> 64 位十六进制数



# 设计模式

## 创建型模式

### 单例模式

目的:

保证一个类只有一个实例， 并提供一个访问该实例的全局节点。最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。

解决两个问题:

1. 一个类只有一个实例.

   实现这类构造函数需要特殊的设计: **必须**总是返回一个新对象。

2. 为该实例提供一个全局访问的节点. 保护唯一实例的数据不被其他代码覆盖.

实现:

- 将默认构造函数设为私有， 防止其他对象使用单例类的 `new`运算符。

- 新建一个静态构建方法作为构造函数。

  该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。

如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。

应用举例:

redux 中的 store

代码实现示例

```typescript
/**
 * The Singleton class defines the `getInstance` method that lets clients access
 * the unique singleton instance.
 */
class Singleton {
    private static instance: Singleton;

    /**
     * The Singleton's constructor should always be private to prevent direct
     * construction calls with the `new` operator.
     */
    private constructor() { }

    /**
     * The static method that controls the access to the singleton instance.
     *
     * This implementation let you subclass the Singleton class while keeping
     * just one instance of each subclass around.
     */
    public static getInstance(): Singleton {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }

        return Singleton.instance;
    }

    /**
     * Finally, any singleton should define some business logic, which can be
     * executed on its instance.
     */
    public someBusinessLogic() {
        // ...
    }
}

/**
 * The client code.
 */
function clientCode() {
    const s1 = Singleton.getInstance();
    const s2 = Singleton.getInstance();

    if (s1 === s2) {
        console.log('Singleton works, both variables contain the same instance.');
    } else {
        console.log('Singleton failed, variables contain different instances.');
    }
}

clientCode();
```



### 生成器模式

背景: 分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。

- 不可能为每一个不同功能的对象都创建一个子类, 子类数量太多. 
- 通过传入参数true/false的形式使用构造函数时, 绝大多数参数又没有用.

原理:

生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为*生成器*的独立对象中。

> 生成器模式让你能够分步骤创建复杂对象。 生成器不允许其他对象访问正在创建中的产品。

![应用生成器模式](https://refactoringguru.cn/images/patterns/diagrams/builder/solution1.png)

重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。

在构造步骤需要不同的实现时, 可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 

> 不同生成器以不同方式执行相同的任务。

![img](https://refactoringguru.cn/images/patterns/content/builder/builder-comic-1-zh.png)

只有在调用构造步骤的客户端代码可以通过通用接口与建造者进行交互时， 这样的调用才能返回需要的房屋。

主管类:

根据实际情况确定是否需要. 主管类中可以放置一些例行程序步骤, 而构造器提供步骤的实现.

> 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。

实现:

![生成器设计模式结构](https://refactoringguru.cn/images/patterns/diagrams/builder/structure.png)

### 原型模式

能够复制已有对象， 而又无需使代码依赖它们所属的类。

直接循环目标对象的所有属性并将其赋值给新对象, 对于有私有属性的对象来说, 并不可行.

原理:

原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 `克隆`方法。

所有的类对 `克隆`方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。

**支持克隆的对象即为*原型*。** 当你的对象有几十个成员变量和几百种类型时， *对其进行克隆甚至可以代替子类的构造*。

其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。

实现:

![原型设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/prototype/structure.png)

### 工厂方法模式

> **亦称：** 虚拟构造函数、Virtual Constructor、Factory Method

在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

不能需要一种实例就创建一个类, 可以避免直接使用 new 进行实例的创建. 

创建子类的构造方法, 实例通过 new 子类得来. 可以在子类中重写工厂方法, 改变创建产品的类型.

![创建者类结构](https://refactoringguru.cn/images/patterns/diagrams/factory-method/solution1.png)

有一点需要注意: 仅当这些产品具有**共同的基类或者接口**时， 子类才能返回不同类型的产品， 同时**基类中的工厂方法**还应将其返回类型 声明为这一共有接口。

![产品对象层次结构](https://refactoringguru.cn/images/patterns/diagrams/factory-method/solution2-zh.png)

举例来说，  `卡车`Truck和 `轮船`Ship类都必须实现 `运输`Transport接口， 该接口声明了一个名为 `deliver`交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。  `陆路运输`Road­Logistics类中的工厂方法返回卡车对象， 而 `海路运输`Sea­Logistics类则返回轮船对象。

实现:

![工厂方法模式结构](https://refactoringguru.cn/images/patterns/diagrams/factory-method/structure.png)

## 结构型模式

### 外观模式

**亦称：** 门面模式、Facade

能为程序库、 框架或其他复杂类提供一个简单的接口。

外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。

如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便，

例如， 上传猫咪搞笑短视频到社交媒体网站的应用可能会用到专业的视频转换库， 但它只需使用一个包含 `encode­(filename, format)`方法 （以文件名与文件格式为参数进行编码的方法） 的类即可。 在创建这个类并将其连接到视频转换库后， 你就拥有了自己的第一个外观。

真实示例:

![电话购物的示例](https://refactoringguru.cn/images/patterns/diagrams/facade/live-example-zh.png)

当你通过电话给商店下达订单时， 接线员就是该商店的所有服务和部门的外观。 接线员为你提供了一个同购物系统、 支付网关和各种送货服务进行互动的简单语音接口。

实现:

1. **外观** （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。

2. 创建**附加外观** （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。

3. **复杂子系统** （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。

   子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。

4. **客户端** （Client） 使用外观代替对子系统对象的直接调用。

![外观设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/facade/structure.png)

### 组合模式

**亦称：** 对象树、Object Tree、Composite

使用它**将对象组合成树状结构**， 并且能像使用独立对象一样使用它们。

背景:

如果应用的核心模型能用树状结构表示， 在应用中使用组合模式才有价值。

例如， 你有两类对象：  `产品`和 `盒子` 。 一个盒子中可以包含多个 `产品`或者几个较小的 `盒子` 。 这些小 `盒子`中同样可以包含一些 `产品`或更小的 `盒子` ， 以此类推。

假设你希望在这些类的基础上开发一个定购系统。 订单中可以包含无包装的简单产品， 也可以包含装满产品的盒子……以及其他盒子。 此时你会如何计算每张订单的总价格呢？

你可以尝试直接计算： 打开所有盒子， 找到每件产品， 然后计算总价。 这在真实世界中或许可行， 但在程序中， 你并不能简单地使用循环语句来完成该工作。 你必须事先知道所有 `产品`和 `盒子`的类别， 所有盒子的嵌套层数以及其他繁杂的细节信息。 因此， 直接计算极不方便， 甚至完全不可行。

解决方案:

组合模式建议使用一个通用接口来与 `产品`和 `盒子`进行交互， 并且在该接口中声明一个计算总价的方法。

那么方法该如何设计呢？ 对于一个产品， 该方法直接返回其价格； 对于一个盒子， 该方法遍历盒子中的所有项目， 询问每个项目的价格， 然后返回该盒子的总价格。 如果其中某个项目是小一号的盒子， 那么当前盒子也会遍历其中的所有项目， 以此类推， 直到计算出所有内部组成部分的价格。 你甚至可以在盒子的最终价格中增加额外费用， 作为该盒子的包装费用。

![组合模式建议的解决方案](https://refactoringguru.cn/images/patterns/content/composite/composite-comic-1-zh.png)

(树的遍历, 例如计算树的深度时, 使用的思想与此类似)

该方式的最大优点在于你无需了解构成树状结构的对象的具体类。 你也无需了解对象是简单的产品还是复杂的盒子。 你只需调用通用接口以相同的方式对其进行处理即可。 当你调用该方法后， 对象会将请求沿着树结构传递下去。

结构:

1. **组件** （Component） 接口描述了树中简单项目和复杂项目所共有的操作。

2. **叶节点** （Leaf） 是树的基本结构， 它不包含子项目。

   一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。

3. **容器** （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。

   容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。

4. **客户端** （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。

![组合设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/composite/structure-zh.png)

应用场景:

1. 如果你需要实现树状对象结构， 可以使用组合模式。

   组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。

2. 如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。

   组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。

### 代理模式

能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。

结构:

1. **服务接口** （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。
2. **服务** （Service） 类提供了一些实用的业务逻辑。
3. **代理** （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。
4. **客户端** （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。

![代理设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/proxy/structure.png)

## 行为模式

### 迭代器模式

能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。

背景:

集合是编程中最常使用的数据类型之一。 尽管如此， 集合只是一组对象的容器而已。大部分集合使用简单列表存储元素。 但有些集合还会使用栈、 树、 图和其他复杂的数据结构。

无论集合的构成方式如何， 它都必须提供某种访问元素的方式， 便于其他代码使用其中的元素。 集合应提供一种能够遍历元素的方式， 且保证它不会周而复始地访问同一个元素。

如果你的集合基于列表， 那么这项工作听上去仿佛很简单。 但如何遍历复杂数据结构 （例如树） 中的元素呢？ 例如， 今天你需要使用深度优先算法来遍历树结构， 明天可能会需要广度优先算法； 下周则可能会需要其他方式 （比如随机存取树中的元素）。

不断向集合中添加遍历算法会模糊其 “高效存储数据” 的主要职责。 此外， 有些算法可能是根据特定应用订制的， 将其加入泛型集合类中会显得非常奇怪。

另一方面， 使用多种集合的客户端代码可能并不关心存储数据的方式。 不过由于集合提供不同的元素访问方式， 你的代码将不得不与特定集合类进行耦合。

总之: 在你不关心数据的存储方式的前提下, 想要访问不同集合中的数据, 但是又不想使用不同的遍历方法, 希望不同的集合都提供统一的方法去访问集合中的数据.

解决:

迭代器模式的主要思想是将集合的遍历行为抽取为单独的*迭代器*对象。

> 迭代器可实现多种遍历算法, 采用不同的方式遍历集合。 多个迭代器对象可同时遍历同一个集合。

![迭代器可以实现不同算法](https://refactoringguru.cn/images/patterns/diagrams/iterator/solution1.png)

除实现自身算法外， 迭代器还封装了遍历操作的所有细节， 例如当前位置和末尾剩余元素的数量。 因此， 多个迭代器可以在相互独立的情况下同时访问集合。

迭代器通常会提供一个获取集合元素的基本方法。 客户端可不断调用该方法直至它不返回任何内容， 这意味着迭代器已经遍历了所有元素。

所有迭代器必须实现相同的接口。 这样一来， 只要有合适的迭代器， 客户端代码就能兼容任何类型的集合或遍历算法。 如果你需要采用特殊方式来遍历集合， 只需创建一个新的迭代器类即可， 无需对集合或客户端进行修改。

结构:

1. **迭代器** （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。

2. **具体迭代器** （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。

3. **集合** （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。

4. **具体集合** （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。

5. **客户端** （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。

   客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。

![迭代器设计模式的结构](https://refactoringguru.cn/images/patterns/diagrams/iterator/structure.png)



### 观察者模式(发布订阅)































