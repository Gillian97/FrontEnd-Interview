# 浏览器

## 网络与互联网

互联网, 连接所有实体计算机, 使得彼此之间可以互相发送数据.

通过互联网, 计算机之间可以发送二进制位. 为了传输能产生有效通信, 计算机之间必须知道这些位应该代表什么. 赋予比特序列的含义取决于想表达的事物的类型以及使用的编码机制.

*网络协议* 描述了网络上的通信方式, 有各种各样的协议, 用来做不同的事情.

*超文本传输协议* (HTTP)是用于检索命名资源(例如网页或者图片之类的信息块)的协议.

发出请求的一方应该采用这样的格式描述请求方式, 想获取的资源以及使用的协议版本.

```http
GET /index.html HTTP/1.1
```

大多数协议都是基于其他协议构建的. HTTP 将网络视为一种类似于流的设备, 可以在其中放置二进制位并以正确的顺序到达目的地.

*传输控制协议* (TCP) , 互联网中的所有设备均使用这个协议, 大多数通信都基于它.
TCP 的工作方式: 一台计算机等待并监听, 以便其他计算机与它建立连接. 一台机器为了同时监听不同类型的通信, 每个监听器占用的端口都不同. 大多数协议都指定了它默认使用的端口. TCP 连接在服务器与客户端之间建立的双向管道, 两端的机器都可以将数据放入其中, TCP 提供了网络的抽象.

## Web

万维网 (World Wide Web) 是一组协议与格式(与互联网概念不同), 允许我们在浏览器中访问网页. `Web` 指的是这样的页面可以相互链接, 形成巨大网格. 换句话说, Web 就是浏览器上能访问的网页的集合.

成为 `Web` 的一部分, 需要其他机器能够到你这里请求文档, 则需要将计算机连接互联网并且使用`HTTP`协议监听80端口.

Web 上的每个文档都由统一资源定位符(URL)命名:

```html
http://qicai.fengniao.com/list_1437.html
|协议 |       服务器       |    路径      |
```

连接到互联网的机器会获得一个 `IP` 地址, 但是IP地址比较难记, 因此可以为 `IP` 地址注册域名, 域名就指向该 `IP` 地址, 对外则可以使用域名来提供服务.

在浏览器中键入该URL, 首先找到域名对应的IP, 然后使用 HTTP 协议与该 IP 对应的服务器建立连接, 然后请求相应的资源, 请求成功, 服务器会发回文档, 浏览器显示即可.

## HTML

HTML : 超文本标记语言(Hypertext Markup Language), 是用于网页的文档格式. 包含文本以及为文本提供结构的标签.

文档以 <!doctype html> 开头, 告诉浏览器将页面解释为现代 html , 而不是过去使用的各种方言.

HTML 中的 \<script\> 标签包含 js 代码, 或者使用`src`属性从`url`获取脚本文件(包含 JavaScript 程序的文本文件). `button`标签的 `onclick` 属性也可以包含 JS 程序. 只要单击按钮, 就会运行属性的值.

```html
<button onclick="alert('Boom!');">DO NOT PRESS</button>
```

将 JS代码严格限制在浏览器中运行, 不能查看或者修改计算机的文件, 是为了防止浏览某些网站时可能出现的恶意脚本攻击. 以这种方式隔离编程环境称为**沙盒化**(sandboxing), 思想是让程序在沙盒中无害运行. 沙盒的难点在于, 既要允许程序有足够的空间运行, 也要限制它做有害的事情.



## 文档对象模型

浏览器从服务器获得 HTML 页面并对其进行解析, 首先构建文档结构的模型, 并使用此模型在屏幕上绘制页面. 这种数据结构可以被读取或者修改, 实时性体现在对其的修改可以立即显示在屏幕上.

将 HTML 想象成嵌套的框, 浏览器表示文档的数据结构就是对这种嵌套的框的模拟, 在这种数据结构中, 每个框都被表示成一个对象, 浏览器可以对其中任何一个对象进行交互, 查看该对象代表什么HTML标签以及包含哪些其他对象以及文本.  这种数据结构被称之为文档对象模型(DOM), documnet.documentElement 是根.

```javascript
// 寻找元素
document.body.getElementsByTagName(arg) // 获取对应标签的所有元素节点列表
document.body.getElementsByClassName(arg) // 获取所有元素节点列表, 其类属性中具有给定字符串
document.getElementsById(arg) // 获取单个元素节点, 该节点的id属性是给定字符串

// 更改文档
appendChild(新节点)
document.body.insertBefore(新节点, 节点) // 将新节点从当前位置移除
replaceChild(新子节点, 旧子节点)

// 创建节点
document.createTextNode(文本内容) // 创建文本节点
document.createElement(标签名称) // 创建元素节点
```

### 属性

getAttribute setAttribute

### 布局

块元素: 占据文档的整个宽度

行内元素: 与周围文本在一行上呈现

offsetWidth offsetHeight 属性表示元素占用的空间(以像素为单位)

### 层叠样式表

使用选择器语法

### 查询选择器

querySelectorAll querySelector



## HTTP 和表单

在浏览器输入 http://qicai.fengniao.com/list_1437.html 之后, 浏览器首先会查询域名对应的IP地址, 然后与其建立TCP连接, 然后在80端口向服务器发送如下信息(请求).

```http
GET /list_1437.html HTTP/1.1
Host: qicai.fengniao.com
User-Agent: 浏览器名称
```

**请求**

请求方法 资源路径 浏览器使用的协议版本

```http
 GET /list_1437.html HTTP/1.1
```

请求方法有: 

```javascript
GET: 获取指定资源
DELETE: 删除资源
PUT: 创建或替换资源
POST: 发送信息
...
```

浏览器在与给定服务器通信时, 会自动切换到适当的协议版本.

指定主机名

服务器可能有多个主机名, 指定是必须的.

```
Host: qicai.fengniao.com
```

**响应**

服务器回复如下信息(响应):

```http
HTTP/1.1 200 OK
Content-Length: 65585
Content-Type: text/html
Last-Modified: Mon, 07 Jan 2020 22:29:54 GMT

<!doctype html>  // 正文
...
```

浏览器收到后, 将正文取出并显示为HTML文档.



协议版本号 状态码 可读字符串

状态码以2开头,表示请求成功, 以4开头说明请求有问题, 以5开头表示服务器有错误.

用来指定请求或者响应的额外信息, 下述表示响应文档的大小和类型以及该文档最后一次被修改的时间.

```
Content-Length: 65585
Content-Type: text/html
Last-Modified: Mon, 07 Jan 2020 22:29:54 GMT
```



请求与响应报文, 都可能包含空行, 后面是正文.



HTML可能包含表单(允许用户填写信息)并将相关信息打包进HTTP请求中, 浏览器随后会显示请求结果.

当form元素的method属性为Get或者省略时, 表单中的信息将作为查询字符串添加到URL的结尾:

```http
GET /list_1437.html?name=Mary&message=Yes%3F HTTP/1.1
```

? 表示资源路径的结束以及查询的开始, %3F是对查询字符串中的?进行转义的结果.

JS 中 `encodeURIComponent`/`decodeURIComponent` 进行编码和解码.

method属性为POST时, 提交表单的HTTP请求会使用POST方法并将查询字符串放在请求正文.

```http
GET /list_1437.html HTTP/1.1
Content-Length: 24
Content-Type: application/x-www-form-urlencoded

name=Mary&message=Yes%3F
```

GET 请求应该用于没有副作用仅仅是要求信息的请求, 更改服务器内容的请求应使用例如POST请求或者其他.

